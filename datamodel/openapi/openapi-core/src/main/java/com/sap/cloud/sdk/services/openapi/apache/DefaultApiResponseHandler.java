/*
 * Prompt Registry API
 * Prompt Storage service for Design time & Runtime prompt templates.
 *
 * The version of the OpenAPI document: 0.0.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.sap.cloud.sdk.services.openapi.apache;

import java.io.File;
import java.io.IOException;
import java.lang.reflect.Type;
import java.nio.charset.UnsupportedCharsetException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;

import org.apache.hc.core5.http.ClassicHttpResponse;
import org.apache.hc.core5.http.ContentType;
import org.apache.hc.core5.http.Header;
import org.apache.hc.core5.http.HttpEntity;
import org.apache.hc.core5.http.HttpResponse;
import org.apache.hc.core5.http.HttpStatus;
import org.apache.hc.core5.http.ParseException;
import org.apache.hc.core5.http.io.HttpClientResponseHandler;
import org.apache.hc.core5.http.io.entity.EntityUtils;
import org.apache.hc.core5.http.message.StatusLine;

import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.sap.cloud.sdk.services.openapi.core.OpenApiRequestException;

/**
 * Handles HTTP response processing for API client operations. This class encapsulates response deserialization, error
 * handling, and file download functionality.
 *
 * @param <T>
 *            The type of object to deserialize the response into
 */
class DefaultApiResponseHandler<T> implements HttpClientResponseHandler<T>
{
    private final ObjectMapper objectMapper;
    private final String tempFolderPath;
    private final TypeReference<T> returnType;

    /**
     * Creates a new response handler with the specified configuration.
     *
     * @param objectMapper
     *            The Jackson ObjectMapper for JSON deserialization
     * @param tempFolderPath
     *            The temporary folder path for file downloads (null for system default)
     * @param returnType
     *            The type reference for response deserialization
     */
    DefaultApiResponseHandler(
        @Nonnull final ObjectMapper objectMapper,
        @Nullable final String tempFolderPath,
        @Nonnull final TypeReference<T> returnType )
    {
        this.objectMapper = objectMapper;
        this.tempFolderPath = tempFolderPath;
        this.returnType = returnType;
    }

    @Nullable
    @Override
    public T handleResponse( @Nonnull final ClassicHttpResponse response )
        throws IOException
    {
        try {
            return processResponse(response);
        }
        catch( ParseException | OpenApiRequestException e ) {
            // Wrap exceptions as IOException since handler can only throw IOException
            throw new IOException("Failed to process response: " + e.getMessage(), e);
        }
    }

    /**
     * Processes the HTTP response and returns the deserialized result.
     *
     * @param response
     *            The HTTP response to process
     * @return The deserialized response object
     * @throws OpenApiRequestException
     *             if the response indicates an error
     * @throws IOException
     *             if an I/O error occurs
     * @throws ParseException
     *             if response parsing fails
     */
    @SuppressWarnings( "unchecked" )
    @Nullable
    private T processResponse( @Nonnull final ClassicHttpResponse response )
        throws OpenApiRequestException,
            IOException,
            ParseException
    {
        final int statusCode = response.getCode();
        if( statusCode == HttpStatus.SC_NO_CONTENT ) {
            if( returnType.getType().equals(OpenApiResponse.class) ) {
                return (T) new OpenApiResponse(statusCode, transformResponseHeaders(response.getHeaders()));
            }
            return null;
        }

        if( isSuccessfulStatus(statusCode) ) {
            return deserialize(response);
        } else {
            final Map<String, List<String>> responseHeaders = transformResponseHeaders(response.getHeaders());
            final String message = new StatusLine(response).toString();
            throw new OpenApiRequestException(message)
                .statusCode(statusCode)
                .responseHeaders(responseHeaders)
                .responseBody(EntityUtils.toString(response.getEntity()));
        }
    }

    /**
     * Deserializes the response body to a Java object according to the Content-Type.
     *
     * @param response
     *            The HTTP response to deserialize
     * @return The deserialized object
     * @throws OpenApiRequestException
     *             if deserialization fails
     * @throws IOException
     *             if an I/O error occurs
     * @throws ParseException
     *             if response parsing fails
     */
    @Nullable
    @SuppressWarnings( "unchecked" )
    private T deserialize( @Nonnull final ClassicHttpResponse response )
        throws OpenApiRequestException,
            IOException,
            ParseException
    {
        if( returnType == null ) {
            return null;
        }

        final Type valueRawType = returnType.getType();
        if( valueRawType.equals(OpenApiResponse.class) ) {
            final int statusCode = response.getCode();
            final Map<String, List<String>> headers = transformResponseHeaders(response.getHeaders());
            return (T) new OpenApiResponse(statusCode, headers);
        }

        final HttpEntity entity = response.getEntity();
        if( valueRawType.equals(byte[].class) ) {
            return (T) EntityUtils.toByteArray(entity);
        } else if( valueRawType.equals(File.class) ) {
            return (T) downloadFileFromResponse(response);
        }
        final String mimeType = getResponseMimeType(response);
        if( mimeType == null || isJsonMime(mimeType) ) {
            // Assume json if no mime type
            // convert input stream to string
            final String content = EntityUtils.toString(entity);

            if( "".equals(content) ) { // returns null for empty body
                return null;
            }

            return objectMapper.readValue(content, returnType);
        } else if( mimeType.toLowerCase().startsWith("text/") ) {
            // convert input stream to string
            return (T) EntityUtils.toString(entity);
        } else {
            final Map<String, List<String>> responseHeaders = transformResponseHeaders(response.getHeaders());
            throw new OpenApiRequestException(
                "Deserialization for content type '" + mimeType + "' not supported for type '" + returnType + "'")
                .statusCode(response.getCode())
                .responseHeaders(responseHeaders)
                .responseBody(EntityUtils.toString(entity));
        }
    }

    /**
     * Downloads a file from the HTTP response.
     *
     * @param response
     *            The HTTP response containing the file
     * @return The downloaded file
     * @throws IOException
     *             if an I/O error occurs during download
     */
    @Nonnull
    private File downloadFileFromResponse( @Nonnull final ClassicHttpResponse response )
        throws IOException
    {
        final Header contentDispositionHeader = response.getFirstHeader("Content-Disposition");
        final String contentDisposition = contentDispositionHeader == null ? null : contentDispositionHeader.getValue();
        final File file = prepareDownloadFile(contentDisposition);
        Files.copy(response.getEntity().getContent(), file.toPath(), StandardCopyOption.REPLACE_EXISTING);
        return file;
    }

    /**
     * Prepares a temporary file for downloading response content.
     *
     * @param contentDisposition
     *            The Content-Disposition header value (may be null)
     * @return A temporary file for storing the download
     * @throws IOException
     *             if the temporary file cannot be created
     */
    @Nonnull
    private File prepareDownloadFile( @Nullable final String contentDisposition )
        throws IOException
    {
        String filename = null;
        if( contentDisposition != null && !contentDisposition.isEmpty() ) {
            // Get filename from the Content-Disposition header.
            final Pattern pattern = Pattern.compile("filename=['\"]?([^'\"\\s]+)['\"]?");
            final Matcher matcher = pattern.matcher(contentDisposition);
            if( matcher.find() ) {
                filename = matcher.group(1);
            }
        }

        String prefix;
        String suffix = null;
        if( filename == null ) {
            prefix = "download-";
            suffix = "";
        } else {
            final int pos = filename.lastIndexOf('.');
            if( pos == -1 ) {
                prefix = filename + "-";
            } else {
                prefix = filename.substring(0, pos) + "-";
                suffix = filename.substring(pos);
            }
            // Files.createTempFile requires the prefix to be at least three characters long
            if( prefix.length() < 3 ) {
                prefix = "download-";
            }
        }

        if( tempFolderPath == null ) {
            return Files.createTempFile(prefix, suffix).toFile();
        }
        return Files.createTempFile(Paths.get(tempFolderPath), prefix, suffix).toFile();
    }

    /**
     * Gets the MIME type from the response Content-Type header.
     *
     * @param response
     *            The HTTP response
     * @return The MIME type, or null if not present
     * @throws OpenApiRequestException
     *             if the content type cannot be parsed
     */
    @Nullable
    private String getResponseMimeType( @Nonnull final HttpResponse response )
        throws OpenApiRequestException
    {
        final Header contentTypeHeader = response.getFirstHeader("Content-Type");
        if( contentTypeHeader != null ) {
            return parseContentType(contentTypeHeader.getValue()).getMimeType();
        }
        return null;
    }

    /**
     * Parses a Content-Type header value into a ContentType object.
     *
     * @param headerValue
     *            The Content-Type header value
     * @return The parsed ContentType object
     * @throws OpenApiRequestException
     *             if the content type cannot be parsed
     */
    @Nonnull
    private static ContentType parseContentType( @Nonnull final String headerValue )
        throws OpenApiRequestException
    {
        try {
            return ContentType.parse(headerValue);
        }
        catch( UnsupportedCharsetException e ) {
            throw new OpenApiRequestException("Could not parse content type " + headerValue, e);
        }
    }

    /**
     * Transforms response headers into map.
     *
     * @param headers
     *            HTTP headers
     * @return a map of string array
     */
    @Nonnull
    private static Map<String, List<String>> transformResponseHeaders( @Nonnull final Header[] headers )
    {
        final Map<String, List<String>> headersMap = new HashMap<>();
        for( final Header header : headers ) {
            List<String> valuesList = headersMap.get(header.getName());
            if( valuesList != null ) {
                valuesList.add(header.getValue());
            } else {
                valuesList = new ArrayList<>();
                valuesList.add(header.getValue());
                headersMap.put(header.getName(), valuesList);
            }
        }
        return headersMap;
    }

    private static boolean isSuccessfulStatus( final int statusCode )
    {
        return statusCode >= 200 && statusCode < 300;
    }

    /**
     * Check if the given MIME is a JSON MIME. JSON MIME examples: application/json application/json; charset=UTF8
     * APPLICATION/JSON application/vnd.company+json
     *
     * @param mime
     *            MIME
     * @return True if MIME type is boolean
     */
    static boolean isJsonMime( @Nullable final String mime )
    {
        final String jsonMime = "(?i)^(application/json|[^;/ \t]+/[^;/ \t]+[+]json)[ \t]*(;.*)?$";
        return mime != null && (mime.matches(jsonMime) || mime.equals("*/*"));
    }

}
