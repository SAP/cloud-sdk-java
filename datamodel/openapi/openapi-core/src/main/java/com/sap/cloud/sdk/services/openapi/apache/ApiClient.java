/*
 * Prompt Registry API
 * Prompt Storage service for Design time & Runtime prompt templates.
 *
 * The version of the OpenAPI document: 0.0.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.sap.cloud.sdk.services.openapi.apache;

import static com.fasterxml.jackson.annotation.JsonInclude.Include.NON_NULL;
import static com.fasterxml.jackson.annotation.PropertyAccessor.GETTER;
import static com.fasterxml.jackson.annotation.PropertyAccessor.SETTER;
import static com.fasterxml.jackson.databind.DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES;
import static com.fasterxml.jackson.databind.MapperFeature.DEFAULT_VIEW_INCLUSION;
import static com.fasterxml.jackson.databind.SerializationFeature.WRITE_DATES_AS_TIMESTAMPS;
import static com.sap.cloud.sdk.services.openapi.apache.DefaultApiResponseHandler.isJsonMime;
import static lombok.AccessLevel.PRIVATE;

import java.io.File;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.nio.charset.UnsupportedCharsetException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

import javax.annotation.Nonnull;
import javax.annotation.Nullable;

import org.apache.hc.client5.http.entity.UrlEncodedFormEntity;
import org.apache.hc.client5.http.entity.mime.MultipartEntityBuilder;
import org.apache.hc.client5.http.impl.classic.CloseableHttpClient;
import org.apache.hc.client5.http.protocol.HttpClientContext;
import org.apache.hc.core5.http.ContentType;
import org.apache.hc.core5.http.HttpEntity;
import org.apache.hc.core5.http.NameValuePair;
import org.apache.hc.core5.http.io.HttpClientResponseHandler;
import org.apache.hc.core5.http.io.entity.ByteArrayEntity;
import org.apache.hc.core5.http.io.entity.FileEntity;
import org.apache.hc.core5.http.io.entity.StringEntity;
import org.apache.hc.core5.http.io.support.ClassicRequestBuilder;
import org.apache.hc.core5.http.message.BasicNameValuePair;

import com.fasterxml.jackson.annotation.JsonAutoDetect.Visibility;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.json.JsonMapper;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import com.google.common.annotations.Beta;
import com.sap.cloud.sdk.cloudplatform.connectivity.ApacheHttpClient5Accessor;
import com.sap.cloud.sdk.cloudplatform.connectivity.Destination;
import com.sap.cloud.sdk.services.openapi.apiclient.RFC3339DateFormat;
import com.sap.cloud.sdk.services.openapi.core.OpenApiRequestException;

import lombok.AllArgsConstructor;
import lombok.EqualsAndHashCode;
import lombok.Getter;
import lombok.ToString;
import lombok.Value;
import lombok.With;

@AllArgsConstructor( access = PRIVATE )
@EqualsAndHashCode
@ToString
public class ApiClient
{
    @Nonnull
    private final CloseableHttpClient httpClient;

    @With
    @Getter
    @Nonnull
    private final String basePath;

    @With( onMethod_ = @Beta )
    @Nonnull
    private final ObjectMapper objectMapper;

    @With
    @Nullable
    private final String tempFolderPath;

    // Methods that can have a request body
    private static final Set<String> BODY_METHODS = Set.of("POST", "PUT", "DELETE", "PATCH");
    private static final String DEFAULT_BASE_PATH = "http://localhost";

    public static ApiClient fromHttpClient( @Nonnull final CloseableHttpClient httpClient )
    {
        return new ApiClient(httpClient, DEFAULT_BASE_PATH, createDefaultObjectMapper(), null);
    }

    public static ApiClient create( @Nonnull final Destination destination )
    {
        return fromHttpClient((CloseableHttpClient) ApacheHttpClient5Accessor.getHttpClient(destination))
            .withBasePath(destination.asHttp().getUri().toString());

    }

    public static ApiClient create()
    {
        return fromHttpClient((CloseableHttpClient) ApacheHttpClient5Accessor.getHttpClient());
    }

    private static ObjectMapper createDefaultObjectMapper()
    {
        return JsonMapper
            .builder()
            .addModule(new JavaTimeModule())
            .defaultDateFormat(new RFC3339DateFormat())
            .visibility(GETTER, Visibility.NONE)
            .visibility(SETTER, Visibility.NONE)
            .defaultPropertyInclusion(JsonInclude.Value.construct(NON_NULL, NON_NULL))
            .disable(FAIL_ON_UNKNOWN_PROPERTIES)
            .disable(DEFAULT_VIEW_INCLUSION)
            .disable(WRITE_DATES_AS_TIMESTAMPS)
            .build();
    }

    /**
     * Format the given Date object into string.
     *
     * @param date
     *            Date
     * @return Date in string format
     */
    private static String formatDate( Date date )
    {
        return new RFC3339DateFormat().format(date);
    }

    /**
     * Format the given parameter object into string.
     *
     * @param param
     *            Object
     * @return Object in string format
     */
    public static String parameterToString( Object param )
    {
        if( param == null ) {
            return "";
        } else if( param instanceof Date ) {
            return formatDate((Date) param);
        } else if( param instanceof Collection ) {
            StringBuilder b = new StringBuilder();
            for( Object o : (Collection<?>) param ) {
                if( b.length() > 0 ) {
                    b.append(',');
                }
                b.append(String.valueOf(o));
            }
            return b.toString();
        } else {
            return String.valueOf(param);
        }
    }

    /**
     * Formats the specified query parameter to a list containing a single {@code Pair} object.
     * <p>
     * Note that {@code value} must not be a collection.
     *
     * @param name
     *            The name of the parameter.
     * @param value
     *            The value of the parameter.
     * @return A list containing a single {@code Pair} object.
     */
    public static List<Pair> parameterToPair( String name, Object value )
    {
        List<Pair> params = new ArrayList<Pair>();

        // preconditions
        if( name == null || name.isEmpty() || value == null || value instanceof Collection ) {
            return params;
        }

        params.add(new Pair(name, escapeString(parameterToString(value))));
        return params;
    }

    /**
     * Formats the specified collection query parameters to a list of {@code Pair} objects.
     * <p>
     * Note that the values of each of the returned Pair objects are percent-encoded.
     *
     * @param collectionFormat
     *            The collection format of the parameter.
     * @param name
     *            The name of the parameter.
     * @param value
     *            The value of the parameter.
     * @return A list of {@code Pair} objects.
     */
    public static List<Pair> parameterToPairs( String collectionFormat, String name, Collection<?> value )
    {
        List<Pair> params = new ArrayList<Pair>();

        // preconditions
        if( name == null || name.isEmpty() || value == null || value.isEmpty() ) {
            return params;
        }

        // create the params based on the collection format
        if( "multi".equals(collectionFormat) ) {
            for( Object item : value ) {
                params.add(new Pair(name, escapeString(parameterToString(item))));
            }
            return params;
        }

        // collectionFormat is assumed to be "csv" by default
        String delimiter = ",";

        // escape all delimiters except commas, which are URI reserved
        // characters
        if( "ssv".equals(collectionFormat) ) {
            delimiter = escapeString(" ");
        } else if( "tsv".equals(collectionFormat) ) {
            delimiter = escapeString("\t");
        } else if( "pipes".equals(collectionFormat) ) {
            delimiter = escapeString("|");
        }

        StringBuilder sb = new StringBuilder();
        for( Object item : value ) {
            sb.append(delimiter);
            sb.append(escapeString(parameterToString(item)));
        }

        params.add(new Pair(name, sb.substring(delimiter.length())));

        return params;
    }

    /**
     * Select the Accept header's value from the given accepts array: if JSON exists in the given array, use it;
     * otherwise use all of them (joining into a string)
     *
     * @param accepts
     *            The accepts array to select from
     * @return The Accept header to use. If the given array is empty, null will be returned (not to set the Accept
     *         header explicitly).
     */
    public static String selectHeaderAccept( String[] accepts )
    {
        if( accepts.length == 0 ) {
            return null;
        }
        for( String accept : accepts ) {
            if( isJsonMime(accept) ) {
                return accept;
            }
        }
        return String.join(",", accepts);
    }

    /**
     * Select the Content-Type header's value from the given array: if JSON exists in the given array, use it; otherwise
     * use the first one of the array.
     *
     * @param contentTypes
     *            The Content-Type array to select from
     * @return The Content-Type header to use. If the given array is empty, or matches "any", JSON will be used.
     */
    public static String selectHeaderContentType( String[] contentTypes )
    {
        if( contentTypes.length == 0 || contentTypes[0].equals("*/*") ) {
            return "application/json";
        }
        for( String contentType : contentTypes ) {
            if( isJsonMime(contentType) ) {
                return contentType;
            }
        }
        return contentTypes[0];
    }

    /**
     * Escape the given string to be used as URL query value.
     *
     * @param str
     *            String
     * @return Escaped string
     */
    public static String escapeString( String str )
    {
        try {
            return URLEncoder.encode(str, "utf8").replaceAll("\\+", "%20");
        }
        catch( UnsupportedEncodingException e ) {
            return str;
        }
    }

    /**
     * Parse content type object from header value
     */
    private ContentType getContentType( String headerValue )
        throws OpenApiRequestException
    {
        try {
            return ContentType.parse(headerValue);
        }
        catch( UnsupportedCharsetException e ) {
            throw new OpenApiRequestException("Could not parse content type " + headerValue);
        }
    }

    /**
     * Serialize the given Java object into string according the given Content-Type (only JSON is supported for now).
     *
     * @param obj
     *            Object
     * @param contentType
     *            Content type
     * @param formParams
     *            Form parameters
     * @return Object
     * @throws OpenApiRequestException
     *             API exception
     */
    private HttpEntity serialize( Object obj, Map<String, Object> formParams, ContentType contentType )
        throws OpenApiRequestException
    {
        String mimeType = contentType.getMimeType();
        if( isJsonMime(mimeType) ) {
            try {
                return new StringEntity(
                    objectMapper.writeValueAsString(obj),
                    contentType.withCharset(StandardCharsets.UTF_8));
            }
            catch( JsonProcessingException e ) {
                throw new OpenApiRequestException(e);
            }
        } else if( mimeType.equals(ContentType.MULTIPART_FORM_DATA.getMimeType()) ) {
            MultipartEntityBuilder multiPartBuilder = MultipartEntityBuilder.create();
            for( Entry<String, Object> paramEntry : formParams.entrySet() ) {
                Object value = paramEntry.getValue();
                if( value instanceof File ) {
                    multiPartBuilder.addBinaryBody(paramEntry.getKey(), (File) value);
                } else if( value instanceof byte[] ) {
                    multiPartBuilder.addBinaryBody(paramEntry.getKey(), (byte[]) value);
                } else {
                    Charset charset = contentType.getCharset();
                    if( charset != null ) {
                        ContentType customContentType =
                            ContentType.create(ContentType.TEXT_PLAIN.getMimeType(), charset);
                        multiPartBuilder
                            .addTextBody(
                                paramEntry.getKey(),
                                parameterToString(paramEntry.getValue()),
                                customContentType);
                    } else {
                        multiPartBuilder.addTextBody(paramEntry.getKey(), parameterToString(paramEntry.getValue()));
                    }
                }
            }
            return multiPartBuilder.build();
        } else if( mimeType.equals(ContentType.APPLICATION_FORM_URLENCODED.getMimeType()) ) {
            List<NameValuePair> formValues = new ArrayList<>();
            for( Entry<String, Object> paramEntry : formParams.entrySet() ) {
                formValues.add(new BasicNameValuePair(paramEntry.getKey(), parameterToString(paramEntry.getValue())));
            }
            return new UrlEncodedFormEntity(formValues, contentType.getCharset());
        } else {
            // Handle files with unknown content type
            if( obj instanceof File ) {
                return new FileEntity((File) obj, contentType);
            } else if( obj instanceof byte[] ) {
                return new ByteArrayEntity((byte[]) obj, contentType);
            }
            throw new OpenApiRequestException("Serialization for content type '" + contentType + "' not supported");
        }
    }

    /**
     * Build full URL by concatenating base URL, the given sub path and query parameters.
     *
     * @param path
     *            The sub path
     * @param queryParams
     *            The query parameters
     * @param collectionQueryParams
     *            The collection query parameters
     * @param urlQueryDeepObject
     *            URL query string of the deep object parameters
     * @return The full URL
     */
    private
        String
        buildUrl( String path, List<Pair> queryParams, List<Pair> collectionQueryParams, String urlQueryDeepObject )
    {
        final StringBuilder url = new StringBuilder();
        if( basePath.endsWith("/") && path != null && path.startsWith("/") ) {
            url.append(basePath, 0, basePath.length() - 1);
        } else {
            url.append(basePath);
        }
        url.append(path);

        if( queryParams != null && !queryParams.isEmpty() ) {
            // support (constant) query string in `path`, e.g. "/posts?draft=1"
            String prefix = path.contains("?") ? "&" : "?";
            for( Pair param : queryParams ) {
                if( param.getValue() != null ) {
                    if( prefix != null ) {
                        url.append(prefix);
                        prefix = null;
                    } else {
                        url.append("&");
                    }
                    String value = parameterToString(param.getValue());
                    // query parameter value already escaped as part of parameterToPair
                    url.append(escapeString(param.getName())).append("=").append(value);
                }
            }
        }

        if( collectionQueryParams != null && !collectionQueryParams.isEmpty() ) {
            String prefix = url.toString().contains("?") ? "&" : "?";
            for( Pair param : collectionQueryParams ) {
                if( param.getValue() != null ) {
                    if( prefix != null ) {
                        url.append(prefix);
                        prefix = null;
                    } else {
                        url.append("&");
                    }
                    String value = parameterToString(param.getValue());
                    // collection query parameter value already escaped as part of parameterToPairs
                    url.append(escapeString(param.getName())).append("=").append(value);
                }
            }
        }

        if( urlQueryDeepObject != null && urlQueryDeepObject.length() > 0 ) {
            url.append(url.toString().contains("?") ? "&" : "?");
            url.append(urlQueryDeepObject);
        }

        return url.toString();
    }

    private static boolean isBodyAllowed( String method )
    {
        return BODY_METHODS.contains(method);
    }

    /**
     * Invoke API by sending HTTP request with the given options.
     *
     * @param <T>
     *            Type
     * @param path
     *            The sub-path of the HTTP URL
     * @param method
     *            The request method, one of "GET", "POST", "PUT", and "DELETE"
     * @param queryParams
     *            The query parameters
     * @param collectionQueryParams
     *            The collection query parameters
     * @param urlQueryDeepObject
     *            A URL query string for deep object parameters
     * @param body
     *            The request body object - if it is not binary, otherwise null
     * @param headerParams
     *            The header parameters
     * @param formParams
     *            The form parameters
     * @param accept
     *            The request's Accept header
     * @param contentType
     *            The request's Content-Type header
     * @param returnType
     *            Return type
     * @return The response body in type of string
     * @throws OpenApiRequestException
     *             API exception
     */
    @Beta
    @Nullable
    public <T> T invokeAPI(
        String path,
        String method,
        List<Pair> queryParams,
        List<Pair> collectionQueryParams,
        String urlQueryDeepObject,
        Object body,
        Map<String, String> headerParams,
        Map<String, Object> formParams,
        String accept,
        String contentType,
        TypeReference<T> returnType )
        throws OpenApiRequestException
    {
        if( body != null && !formParams.isEmpty() ) {
            throw new OpenApiRequestException("Cannot have body and form params");
        }

        final String url = buildUrl(path, queryParams, collectionQueryParams, urlQueryDeepObject);

        ClassicRequestBuilder builder = ClassicRequestBuilder.create(method);
        builder.setUri(url);

        if( accept != null ) {
            builder.addHeader("Accept", accept);
        }
        for( Entry<String, String> keyValue : headerParams.entrySet() ) {
            builder.addHeader(keyValue.getKey(), keyValue.getValue());
        }

        HttpClientContext context = HttpClientContext.create();

        ContentType contentTypeObj = getContentType(contentType);
        if( body != null || !formParams.isEmpty() ) {
            if( isBodyAllowed(method) ) {
                // Add entity if we have content and a valid method
                builder.setEntity(serialize(body, formParams, contentTypeObj));
            } else {
                throw new OpenApiRequestException("method " + method + " does not support a request body");
            }
        } else {
            // for empty body
            builder.setEntity(new StringEntity("", contentTypeObj));
        }

        try {
            HttpClientResponseHandler<T> responseHandler =
                new DefaultApiResponseHandler<>(objectMapper, tempFolderPath, returnType);
            return httpClient.execute(builder.build(), context, responseHandler);
        }
        catch( IOException e ) {
            throw new OpenApiRequestException(e);
        }
    }
}
