/*
 * Copyright (c) 2023 SAP SE or an SAP affiliate company. All rights reserved.
 */

package com.sap.cloud.sdk.datamodel.odatav4.generator;

import static org.assertj.core.api.Assertions.assertThat;

import java.io.File;
import java.lang.reflect.Field;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;

import org.apache.commons.lang3.StringUtils;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.io.TempDir;

import com.sun.codemodel.JCodeModel;

class GeneratorReferenceTest
{
    private static final String REFLECTION_FIELD_CODE_MODEL = "codeModel";
    private static final String TEST_PACKAGE_NAMESPACE = "org.example.namespace";
    private static final String TEST_PACKAGE_SERVICE = "org.example.service";

    interface CodeModelHandler
    {
        void call( JCodeModel codeModel )
            throws Exception;
    }

    @Test
    void testWithoutGeneratorReference( @TempDir final Path tempDir )
        throws Exception
    {
        final String className = "MyClass";
        final String packageName = "org.example";

        workCodeModel(tempDir, false, c -> c._package(packageName)._class(className));

        // check package
        final Path pathPackage = tempDir.resolve(StringUtils.replace(packageName, ".", File.separator));
        assertThat(pathPackage).exists().isDirectory();

        // check java file
        final Path pathClass = pathPackage.resolve(className + ".java");
        assertThat(pathClass).exists().isRegularFile();

        // validate copyright
        final List<String> classLines = Files.readAllLines(pathClass);
        assertThat(classLines).isNotEmpty();
        assertThat(classLines).noneMatch(s -> s.contains("Copyright"));

        // validate missing generator reference
        assertThat(classLines).noneMatch(s -> s.contains("Generated by"));
    }

    @Test
    void testWithGeneratorReference( @TempDir final Path tempDir )
        throws Exception
    {
        final String interfaceName = "MyInterface";
        final String packageName = "org.example";

        workCodeModel(tempDir, true, c -> c._package(packageName)._interface(interfaceName));

        // check package
        final Path pathPackage = tempDir.resolve(StringUtils.replace(packageName, ".", File.separator));
        assertThat(pathPackage).exists().isDirectory();

        // check java file
        final Path pathInterface = pathPackage.resolve(interfaceName + ".java");
        assertThat(pathInterface).exists().isRegularFile();

        // validate existing generator reference
        final List<String> classLines = Files.readAllLines(pathInterface);
        assertThat(classLines).anyMatch(s -> s.contains("Generated by"));
    }

    private
        void
        workCodeModel( @TempDir final Path tempDir, final boolean referenceVersion, final CodeModelHandler handler )
            throws Exception
    {
        final DataModelGenerator config =
            new DataModelGenerator().withOutputDirectory(tempDir.toFile()).versionReference(referenceVersion);

        final CodeModelClassGenerator generator =
            new CodeModelClassGenerator(config, TEST_PACKAGE_NAMESPACE, TEST_PACKAGE_SERVICE);

        // access code model variable
        final Field field = CodeModelClassGenerator.class.getDeclaredField(REFLECTION_FIELD_CODE_MODEL);
        field.setAccessible(true);
        final JCodeModel codeModel = (JCodeModel) field.get(generator);

        // work code model
        handler.call(codeModel);

        // trigger file writing of generated code
        generator.writeClasses(config, Charset.defaultCharset());
    }
}
